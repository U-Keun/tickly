name: CD

on:
  push:
    tags: ["v*.*.*"]
  workflow_dispatch:
    inputs:
      build_ios:
        description: Build and upload iOS app to TestFlight
        required: true
        type: boolean
        default: true
      build_desktop:
        description: Build desktop bundles (macOS, Windows, Linux)
        required: true
        type: boolean
        default: true
      create_release:
        description: Create GitHub draft release with desktop artifacts
        required: true
        type: boolean
        default: true

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  validate-release-version:
    name: Validate Release Version
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Validate package/Tauri version and git tag
        env:
          GITHUB_REF: ${{ github.ref }}
        run: |
          node <<'NODE'
          const fs = require('fs');

          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          const tauri = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
          const ref = process.env.GITHUB_REF ?? '';
          const isTagRef = ref.startsWith('refs/tags/');
          const tag = isTagRef ? ref.replace('refs/tags/', '') : '';
          const normalizedTag = tag.startsWith('v') ? tag.slice(1) : tag;

          if (pkg.version !== tauri.version) {
            console.error(`Version mismatch: package.json=${pkg.version}, tauri.conf.json=${tauri.version}`);
            process.exit(1);
          }

          if (isTagRef && normalizedTag !== pkg.version) {
            console.error(`Tag version mismatch: git tag=${tag}, app version=${pkg.version}`);
            process.exit(1);
          }

          console.log(`Version validation OK: ${pkg.version}`);
          NODE

  preflight-desktop:
    name: Preflight Desktop Secrets
    runs-on: ubuntu-latest
    needs: [validate-release-version]
    if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.build_desktop)
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
    steps:
      - name: Ensure required secrets exist
        run: |
          missing=()
          [[ -n "${SUPABASE_URL}" ]] || missing+=("SUPABASE_URL")
          [[ -n "${SUPABASE_ANON_KEY}" ]] || missing+=("SUPABASE_ANON_KEY")

          if [ ${#missing[@]} -gt 0 ]; then
            echo "Missing required secrets: ${missing[*]}"
            exit 1
          fi

  preflight-ios:
    name: Preflight iOS Secrets
    runs-on: ubuntu-latest
    needs: [validate-release-version]
    if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.build_ios)
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
      IOS_CERTIFICATE_P12: ${{ secrets.IOS_CERTIFICATE_P12 }}
      IOS_CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
      IOS_PROVISIONING_PROFILE: ${{ secrets.IOS_PROVISIONING_PROFILE }}
      APP_STORE_CONNECT_API_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
      APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
      APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY_CONTENT }}
    steps:
      - name: Ensure required secrets exist
        run: |
          missing=()
          [[ -n "${SUPABASE_URL}" ]] || missing+=("SUPABASE_URL")
          [[ -n "${SUPABASE_ANON_KEY}" ]] || missing+=("SUPABASE_ANON_KEY")
          [[ -n "${IOS_CERTIFICATE_P12}" ]] || missing+=("IOS_CERTIFICATE_P12")
          [[ -n "${IOS_CERTIFICATE_PASSWORD}" ]] || missing+=("IOS_CERTIFICATE_PASSWORD")
          [[ -n "${IOS_PROVISIONING_PROFILE}" ]] || missing+=("IOS_PROVISIONING_PROFILE")
          [[ -n "${APP_STORE_CONNECT_API_ISSUER_ID}" ]] || missing+=("APP_STORE_CONNECT_API_ISSUER_ID")
          [[ -n "${APP_STORE_CONNECT_API_KEY_ID}" ]] || missing+=("APP_STORE_CONNECT_API_KEY_ID")
          [[ -n "${APP_STORE_CONNECT_API_KEY_CONTENT}" ]] || missing+=("APP_STORE_CONNECT_API_KEY_CONTENT")

          if [ ${#missing[@]} -gt 0 ]; then
            echo "Missing required secrets: ${missing[*]}"
            exit 1
          fi

  build-ios:
    name: Build iOS (TestFlight)
    runs-on: macos-latest
    needs: [preflight-ios]
    if: needs.preflight-ios.result == 'success'
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
      IOS_CERTIFICATE: ${{ secrets.IOS_CERTIFICATE_P12 }}
      IOS_CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
      IOS_MOBILE_PROVISION: ${{ secrets.IOS_PROVISIONING_PROFILE }}
    steps:
      - uses: actions/checkout@v4

      - name: Select Xcode 26.2
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "26.2"

      - name: Verify iOS SDK version
        run: |
          xcodebuild -version
          SDK_VER="$(xcrun --sdk iphoneos --show-sdk-version)"
          SDK_MAJOR="${SDK_VER%%.*}"
          echo "Detected iOS SDK version: $SDK_VER"
          if ! [[ "$SDK_MAJOR" =~ ^[0-9]+$ ]] || [ "$SDK_MAJOR" -lt 26 ]; then
            echo "iOS SDK 26 or later is required. Current SDK: $SDK_VER"
            exit 1
          fi

      - name: Force default Xcode toolchain
        run: |
          echo "TOOLCHAINS=com.apple.dt.toolchain.XcodeDefault" >> $GITHUB_ENV
          echo "Using TOOLCHAINS=com.apple.dt.toolchain.XcodeDefault"

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: yarn

      - run: yarn install --frozen-lockfile

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios

      - uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            src-tauri/target/
          key: cargo-ios-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: cargo-ios-

      - name: Build frontend (required for iOS)
        run: yarn build

      - name: Resolve iOS app version and build number
        run: |
          APP_VERSION=$(node -p "require('./package.json').version")
          IOS_BUILD_NUMBER="${GITHUB_RUN_NUMBER}"

          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "IOS_BUILD_NUMBER=$IOS_BUILD_NUMBER" >> $GITHUB_ENV
          echo "Using APP_VERSION=$APP_VERSION IOS_BUILD_NUMBER=$IOS_BUILD_NUMBER"

      - name: Import signing certificate to keychain
        run: |
          CERT_PATH="$RUNNER_TEMP/certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          KEYCHAIN_PASSWORD=$(openssl rand -hex 16)

          echo "IOS_KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "IOS_KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          echo -n "$IOS_CERTIFICATE" | base64 --decode > "$CERT_PATH"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security import "$CERT_PATH" -P "$IOS_CERTIFICATE_PASSWORD" -A -f pkcs12 -k "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" /Users/runner/Library/Keychains/login.keychain-db
          security default-keychain -d user -s "$KEYCHAIN_PATH"
          IDENTITY_COUNT=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | tee "$RUNNER_TEMP/codesign-identities.txt" | awk '/valid identities found/{print $1; exit}')
          if ! [[ "$IDENTITY_COUNT" =~ ^[0-9]+$ ]] || [ "$IDENTITY_COUNT" -lt 1 ]; then
            echo "No valid codesigning identities were imported from IOS_CERTIFICATE_P12."
            exit 1
          fi

      - name: Validate provisioning profile for App Store export
        run: |
          PROFILE_PATH=$RUNNER_TEMP/profile.mobileprovision
          echo -n "$IOS_MOBILE_PROVISION" | base64 --decode > "$PROFILE_PATH"
          security cms -D -i "$PROFILE_PATH" > "$RUNNER_TEMP/profile.plist"

          TEAM_ID=$(/usr/libexec/PlistBuddy -c "Print :TeamIdentifier:0" "$RUNNER_TEMP/profile.plist")
          if [ -z "$TEAM_ID" ]; then
            echo "Failed to extract TeamIdentifier from provisioning profile"
            exit 1
          fi
          echo "APPLE_DEVELOPMENT_TEAM=$TEAM_ID" >> $GITHUB_ENV

          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$RUNNER_TEMP/profile.plist")
          if [ -z "$PROFILE_UUID" ]; then
            echo "Failed to extract UUID from provisioning profile"
            exit 1
          fi
          echo "IOS_PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV

          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" "$RUNNER_TEMP/profile.plist")
          if [ -z "$PROFILE_NAME" ]; then
            echo "Failed to extract Name from provisioning profile"
            exit 1
          fi
          echo "IOS_PROFILE_NAME=$PROFILE_NAME" >> $GITHUB_ENV

          # TestFlight/App Store export needs a distribution profile (not development).
          GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:get-task-allow" "$RUNNER_TEMP/profile.plist" 2>/dev/null || echo "unknown")
          if [ "$GET_TASK_ALLOW" = "true" ]; then
            echo "Provided IOS_PROVISIONING_PROFILE appears to be a Development profile."
            echo "Use an App Store / Distribution provisioning profile for TestFlight export."
            exit 1
          fi

          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp "$PROFILE_PATH" ~/Library/MobileDevice/Provisioning\ Profiles/

      - name: Initialize iOS project
        run: yarn tauri ios init --ci

      - name: Apply custom iOS app icon
        run: |
          ICON_SRC="src-tauri/icons/icon.png"
          APPICON_DIR="src-tauri/gen/apple/Assets.xcassets/AppIcon.appiconset"

          if [ ! -f "$ICON_SRC" ]; then
            echo "Missing icon source: $ICON_SRC"
            exit 1
          fi
          if [ ! -d "$APPICON_DIR" ]; then
            echo "Missing iOS AppIcon set: $APPICON_DIR"
            exit 1
          fi

          for icon_path in "$APPICON_DIR"/AppIcon-*.png; do
            icon_name=$(basename "$icon_path")
            size_part=$(echo "$icon_name" | sed -E 's/^AppIcon-([0-9.]+)(x[0-9.]+)?@([0-9]+)x.*\.png$/\1 \3/')
            point_size=$(echo "$size_part" | awk '{print $1}')
            scale=$(echo "$size_part" | awk '{print $2}')

            if [ -z "$point_size" ] || [ -z "$scale" ]; then
              echo "Failed to parse icon size from $icon_name"
              exit 1
            fi

            pixel_size=$(awk "BEGIN { printf \"%d\", $point_size * $scale }")
            /usr/bin/sips -z "$pixel_size" "$pixel_size" "$ICON_SRC" --out "$icon_path" >/dev/null
          done

          echo "Applied custom icon from $ICON_SRC"
          /usr/bin/sips -g pixelWidth -g pixelHeight "$APPICON_DIR/AppIcon-60x60@2x.png" 2>/dev/null || true

      - name: Remove duplicate libapp resource entries
        run: |
          PBXPROJ="src-tauri/gen/apple/tickly.xcodeproj/project.pbxproj"
          echo "Before cleanup:"
          rg -n "libapp\\.a in Resources" "$PBXPROJ" || true

          # Keep libapp.a linked in Frameworks, but remove resource copy entries
          # that cause "Multiple commands produce .../Tickly.app/libapp.a".
          sed -i '' '/libapp\.a in Resources/d' "$PBXPROJ"

          echo "After cleanup:"
          rg -n "libapp\\.a in Resources" "$PBXPROJ" || true

      - name: Configure Xcode signing with provisioning profile
        run: |
          PBXPROJ="src-tauri/gen/apple/tickly.xcodeproj/project.pbxproj"

          set_or_add() {
            path="$1"
            value="$2"
            /usr/libexec/PlistBuddy -c "Set $path \"$value\"" "$PBXPROJ" 2>/dev/null || \
              /usr/libexec/PlistBuddy -c "Add $path string \"$value\"" "$PBXPROJ"
          }

          CONFIG_IDS=$(/usr/libexec/PlistBuddy -c "Print :objects" "$PBXPROJ" | awk '/ = Dict/ {k=$1} /isa = XCBuildConfiguration/ {gsub("=", "", k); print k}')
          for id in $CONFIG_IDS; do
            bundle_id=$(/usr/libexec/PlistBuddy -c "Print :objects:$id:buildSettings:PRODUCT_BUNDLE_IDENTIFIER" "$PBXPROJ" 2>/dev/null || true)
            if [ "$bundle_id" = "com.u-keunsong.tickly" ]; then
              set_or_add ":objects:$id:buildSettings:CODE_SIGN_STYLE" "Manual"
              set_or_add ":objects:$id:buildSettings:DEVELOPMENT_TEAM" "$APPLE_DEVELOPMENT_TEAM"
              set_or_add ":objects:$id:buildSettings:CODE_SIGN_IDENTITY" "Apple Distribution"
              set_or_add ":objects:$id:buildSettings:TOOLCHAINS" "com.apple.dt.toolchain.XcodeDefault"
              set_or_add ":objects:$id:buildSettings:ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES" "YES"
              set_or_add ":objects:$id:buildSettings:LIBRARY_SEARCH_PATHS" '$(inherited) /Applications/Xcode_26.2.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/$(PLATFORM_NAME) /Applications/Xcode_26.2.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift-5.0/$(PLATFORM_NAME)'
              set_or_add ":objects:$id:buildSettings:PROVISIONING_PROFILE" "$IOS_PROFILE_UUID"
              set_or_add ":objects:$id:buildSettings:PROVISIONING_PROFILE_SPECIFIER" "$IOS_PROFILE_NAME"
              set_or_add ":objects:$id:buildSettings:MARKETING_VERSION" "$APP_VERSION"
              set_or_add ":objects:$id:buildSettings:CURRENT_PROJECT_VERSION" "$IOS_BUILD_NUMBER"
              set_or_add ":objects:$id:buildSettings:SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD" "NO"
              set_or_add ":objects:$id:buildSettings:SUPPORTED_PLATFORMS" "iphoneos iphonesimulator"
            fi
          done

      - name: Set iOS bundle version values
        run: |
          INFO_PLIST="src-tauri/gen/apple/tickly_iOS/Info.plist"

          set_or_add_plist() {
            key="$1"
            value="$2"
            /usr/libexec/PlistBuddy -c "Set :$key $value" "$INFO_PLIST" 2>/dev/null || \
              /usr/libexec/PlistBuddy -c "Add :$key string $value" "$INFO_PLIST"
          }

          set_or_add_plist "CFBundleShortVersionString" "$APP_VERSION"
          set_or_add_plist "CFBundleVersion" "$IOS_BUILD_NUMBER"

      - name: Ensure iOS URL scheme for OAuth callback
        run: |
          INFO_PLIST="src-tauri/gen/apple/tickly_iOS/Info.plist"
          /usr/libexec/PlistBuddy -c "Delete :CFBundleURLTypes" "$INFO_PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :CFBundleURLTypes array" "$INFO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :CFBundleURLTypes:0 dict" "$INFO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :CFBundleURLTypes:0:CFBundleURLName string com.u-keunsong.tickly" "$INFO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :CFBundleURLTypes:0:CFBundleURLSchemes array" "$INFO_PLIST"
          /usr/libexec/PlistBuddy -c "Add :CFBundleURLTypes:0:CFBundleURLSchemes:0 string tickly" "$INFO_PLIST"

      - name: Build iOS IPA (tauri ios build)
        run: |
          EXPORT_METHODS=("app-store-connect" "release-testing")
          BUILD_OK=0

          for EXPORT_METHOD in "${EXPORT_METHODS[@]}"; do
            echo "Trying tauri ios build with export method: $EXPORT_METHOD"
            if yarn tauri ios build --ci --build-number "$IOS_BUILD_NUMBER" --export-method "$EXPORT_METHOD"; then
              echo "IOS_EXPORT_METHOD=$EXPORT_METHOD" >> $GITHUB_ENV
              BUILD_OK=1
              break
            fi
            echo "tauri ios build failed with export method: $EXPORT_METHOD"

            ARCHIVE_PATH=$(find src-tauri/gen/apple/build -name "*.xcarchive" -type d | head -1)
            if [ -z "$ARCHIVE_PATH" ]; then
              echo "No .xcarchive found after tauri build failure."
              continue
            fi

            echo "Trying manual xcodebuild export from archive: $ARCHIVE_PATH"
            MANUAL_EXPORT_PATH="$RUNNER_TEMP/ios-export-$EXPORT_METHOD"
            EXPORT_OPTIONS_PLIST="$RUNNER_TEMP/ExportOptions-$EXPORT_METHOD.plist"
            rm -rf "$MANUAL_EXPORT_PATH"
            mkdir -p "$MANUAL_EXPORT_PATH"

            cat > "$EXPORT_OPTIONS_PLIST" <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>${EXPORT_METHOD}</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>teamID</key>
            <string>${APPLE_DEVELOPMENT_TEAM}</string>
            <key>signingCertificate</key>
            <string>Apple Distribution</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>com.u-keunsong.tickly</key>
              <string>${IOS_PROFILE_NAME}</string>
            </dict>
          </dict>
          </plist>
          EOF

            if xcodebuild \
              -exportArchive \
              -archivePath "$ARCHIVE_PATH" \
              -exportPath "$MANUAL_EXPORT_PATH" \
              -exportOptionsPlist "$EXPORT_OPTIONS_PLIST"; then
              echo "Manual xcodebuild export succeeded with method: $EXPORT_METHOD"
              echo "IOS_EXPORT_METHOD=$EXPORT_METHOD" >> $GITHUB_ENV
              echo "IOS_MANUAL_EXPORT_PATH=$MANUAL_EXPORT_PATH" >> $GITHUB_ENV
              BUILD_OK=1
              break
            fi

            echo "Manual xcodebuild export failed with method: $EXPORT_METHOD"
          done

          if [ "$BUILD_OK" -ne 1 ]; then
            echo "Failed to build/export IPA with all supported methods."
            exit 1
          fi

      - name: Debug iOS signing settings (on failure)
        if: failure()
        run: |
          set +e
          xcodebuild -workspace src-tauri/gen/apple/tickly.xcodeproj/project.xcworkspace -scheme tickly_iOS -showBuildSettings | egrep "PRODUCT_BUNDLE_IDENTIFIER|DEVELOPMENT_TEAM|CODE_SIGN_STYLE|CODE_SIGN_IDENTITY|PROVISIONING_PROFILE|MARKETING_VERSION|CURRENT_PROJECT_VERSION"
          security find-identity -v -p codesigning "$IOS_KEYCHAIN_PATH"

      - name: Debug iOS export logs (on failure)
        if: failure()
        run: |
          set +e
          LOG_DIR=$(ls -td /var/folders/*/*/*/T/*.xcdistributionlogs 2>/dev/null | head -1)
          echo "Latest xcdistributionlogs: ${LOG_DIR:-not found}"
          if [ -n "$LOG_DIR" ]; then
            find "$LOG_DIR" -type f | sort
            find "$LOG_DIR" -type f -name "*.log" -print -exec tail -n 200 {} \;
          fi

      - name: Find IPA file
        id: find-ipa
        run: |
          IPA_PATH=$(find "${IOS_MANUAL_EXPORT_PATH:-src-tauri/gen/apple/build}" src-tauri/gen/apple/build -name "*.ipa" -type f | head -1)
          if [ -z "$IPA_PATH" ]; then
            echo "No IPA file found in manual export path or src-tauri/gen/apple/build"
            exit 1
          fi
          echo "ipa_path=$IPA_PATH" >> $GITHUB_OUTPUT
          echo "Found IPA: $IPA_PATH"

      - uses: actions/upload-artifact@v4
        with:
          name: ios-ipa
          path: ${{ steps.find-ipa.outputs.ipa_path }}
          retention-days: 7

      - name: Upload to TestFlight
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: ${{ steps.find-ipa.outputs.ipa_path }}
          issuer-id: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
          api-key-id: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          api-private-key: ${{ secrets.APP_STORE_CONNECT_API_KEY_CONTENT }}

      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain "$IOS_KEYCHAIN_PATH" || true

  build-desktop:
    name: Build Desktop (${{ matrix.platform }})
    needs: [preflight-desktop]
    if: needs.preflight-desktop.result == 'success'
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos
            runner: macos-latest
            artifact-glob: |
              src-tauri/target/release/bundle/dmg/*.dmg
          - platform: windows
            runner: windows-latest
            artifact-glob: |
              src-tauri/target/release/bundle/msi/*.msi
              src-tauri/target/release/bundle/nsis/*.exe
          - platform: linux
            runner: ubuntu-latest
            artifact-glob: |
              src-tauri/target/release/bundle/deb/*.deb
              src-tauri/target/release/bundle/appimage/*.AppImage
    runs-on: ${{ matrix.runner }}
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: yarn

      - run: yarn install --frozen-lockfile

      - name: Install Linux dependencies
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev

      - uses: dtolnay/rust-toolchain@stable

      - uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            src-tauri/target/
          key: cargo-${{ matrix.platform }}-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: cargo-${{ matrix.platform }}-

      - run: yarn tauri build

      - uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.platform }}
          path: ${{ matrix.artifact-glob }}
          retention-days: 7

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [build-desktop]
    if: startsWith(github.ref, 'refs/tags/v') && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.create_release)) && needs.build-desktop.result == 'success'
    permissions:
      contents: write
    steps:
      - uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: List artifacts
        run: find artifacts -type f | sort

      - uses: softprops/action-gh-release@v2
        with:
          files: artifacts/**/*
          generate_release_notes: true
          draft: true
